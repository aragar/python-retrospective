from itertools import count
from collections import OrderedDict


def groupby(func, seq):
    """ Group values in `seq` on keys generated by `func` and return a dict.

    """
    return {result: [item for item in seq if func(item) == result] for
            result in set(map(func, seq))}


def iterate(func):
    """ Return the iteration of `func`.

    Generate infinite sequence of compositions of `func`. The n-th element
    in the sequence is the composition of (n - 1) functions.

    The first element is the identity function.

    """
    def iterate_times(times, x):
        result = x

        for i in range(times):
            result = func(result)

        return result

    for times in count():
        yield lambda x: iterate_times(times, x)


def zip_with(func, *iterables):
    """ Generate sequence of elements where the n-th element is the result of
    `func` applied to the n-th elements of all `iterables.`

    """
    return (func(*args) for args in zip(*iterables))


def cache(func, cache_size):
    """ Return a function that caches the last `cache_size` results of `func`.

    Returns `func` if `cache_size` is <= 0

    """
    store = OrderedDict()

    def func_cached(*args):
        if args in store:
            return store[args]

        result = func(*args)

        if cache_size:
            if len(store) == cache_size:
                store.popitem(False)
            store[args] = result

        return result

    return func_cached
